"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os = require("os");
const path = require("path");
const chalk_1 = require("chalk");
const Debug = require("debug");
const lodash = require("lodash");
const fs_1 = require("@ionic/cli-framework/utils/fs");
const errors_1 = require("../errors");
var guards_1 = require("../../guards");
exports.INTEGRATION_NAMES = guards_1.INTEGRATION_NAMES;
const debug = Debug('ionic:cli-utils:lib:integrations');
class BaseIntegration {
    constructor(e) {
        this.e = e;
    }
    static createFromName(deps, name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (name === 'capacitor') {
                const { Integration } = yield Promise.resolve().then(() => require('./capacitor'));
                return new Integration(deps);
            }
            else if (name === 'cordova') {
                const { Integration } = yield Promise.resolve().then(() => require('./cordova'));
                return new Integration(deps);
            }
            throw new errors_1.IntegrationNotFoundException(`Bad integration name: ${chalk_1.default.bold(name)}`); // TODO?
        });
    }
    getInfo() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return [];
        });
    }
    enable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // optionally overwritten by subclasses
        });
    }
    disable() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // optionally overwritten by subclasses
        });
    }
    personalize(details) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // optionally overwritten by subclasses
        });
    }
    add(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.archiveUrl) {
                return;
            }
            const onFileCreate = opts && opts.onFileCreate ? opts.onFileCreate : lodash.noop;
            const conflictHandler = opts && opts.conflictHandler ? opts.conflictHandler : () => tslib_1.__awaiter(this, void 0, void 0, function* () { return false; });
            const { createRequest, download } = yield Promise.resolve().then(() => require('../utils/http'));
            const { tar } = yield Promise.resolve().then(() => require('../utils/archive'));
            this.e.log.info(`Downloading integration ${chalk_1.default.green(this.name)}`);
            const tmpdir = path.resolve(os.tmpdir(), `ionic-integration-${this.name}`);
            // TODO: etag
            if (yield fs_1.pathExists(tmpdir)) {
                yield fs_1.removeDirectory(tmpdir);
            }
            yield fs_1.fsMkdirp(tmpdir, 0o777);
            const ws = tar.extract({ cwd: tmpdir });
            const { req } = yield createRequest('GET', this.archiveUrl, this.e.config.getHTTPConfig());
            yield download(req, ws, {});
            const contents = yield fs_1.readDir(tmpdir);
            const blacklist = [];
            debug(`Integration files downloaded to ${chalk_1.default.bold(tmpdir)} (files: ${contents.map(f => chalk_1.default.bold(f)).join(', ')})`);
            for (const f of contents) {
                const projectf = path.resolve(this.e.project.directory, f);
                try {
                    const stats = yield fs_1.fsStat(projectf);
                    const overwrite = yield conflictHandler(projectf, stats);
                    if (!overwrite) {
                        blacklist.push(f);
                    }
                }
                catch (e) {
                    if (e.code !== 'ENOENT') {
                        throw e;
                    }
                }
            }
            this.e.log.info(`Copying integrations files to project`);
            debug(`Blacklist: ${blacklist.map(f => chalk_1.default.bold(f)).join(', ')}`);
            yield fs_1.copyDirectory(tmpdir, this.e.project.directory, {
                filter: f => {
                    if (f === tmpdir) {
                        return true;
                    }
                    const projectf = f.substring(tmpdir.length + 1);
                    for (const item of blacklist) {
                        if (item.slice(-1) === '/' && `${projectf}/` === item) {
                            return false;
                        }
                        if (projectf.startsWith(item)) {
                            return false;
                        }
                    }
                    onFileCreate(projectf);
                    return true;
                },
            });
            yield this.enable();
        });
    }
}
exports.BaseIntegration = BaseIntegration;
